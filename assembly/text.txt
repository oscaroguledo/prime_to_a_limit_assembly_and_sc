section .text
global EncryptVigenere

EncryptVigenere:
    push rbp
    mov rbp, rsp

    ; Parameters:
    ; rdi = plaintext pointer
    ; rsi = key pointer
    ; rdx = plaintext length

    xor rcx, rcx     ; plaintext index
    xor rbx, rbx     ; key index

loop:
    cmp rcx, rdx     ; compare plaintext index to plaintext length
    jge end_loop     ; if plaintext index >= plaintext length, exit loop

    mov al, [rdi + rcx]  ; get plaintext byte
    mov bl, [rsi + rbx]  ; get key byte

    cmp al, 'a'
    jl not_lowercase
    cmp al, 'z'
    jg not_lowercase
    
    ; plaintext is lowercase
    sub al, 'a'  ; convert to 0-25
    jmp encrypt
    
not_lowercase:
    cmp al, 'A'
    jl not_uppercase
    cmp al, 'Z'
    jg not_uppercase
    
    ; plaintext is uppercase
    sub al, 'A'  ; convert to 0-25
    jmp encrypt
    
not_uppercase:
    ; not a letter, keep plaintext byte unchanged
    jmp end_loop
    
encrypt:
    cmp bl, 'a'
    jl key_not_lowercase
    cmp bl, 'z'
    jg key_not_lowercase
    
    ; key is lowercase
    sub bl, 'a'  ; convert to 0-25
    jmp add_key
    
key_not_lowercase:
    cmp bl, 'A'
    jl key_not_uppercase 
    cmp bl, 'Z'
    jg key_not_uppercase
    
    ; key is uppercase
    sub bl, 'A'  ; convert to 0-25
    jmp add_key
   
key_not_uppercase:
    ; key not a letter, use 0
    
add_key:
    add al, bl     ; add plaintext and key
    mov bl, 26

    cmp bl, 0      ; Check if divisor (bl) is zero
    je divisor_zero

    div bl          ; modulo 26
    jmp divisor_not_zero

    divisor_zero:
        ; Handle division by zero case here
        ; You might want to set a default value or handle it as needed

    divisor_not_zero:
        add al, 'a'  ; convert back to ASCII
    mov [rdi + rcx], al  ; store encrypted byte

    
end_loop:
    inc rcx  ; increment plaintext index 
    inc rbx  ; increment key index
    jmp loop  ; continue loop

end_encryption:
    pop rbp
    ret
